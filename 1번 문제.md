# 동시에 같은 DB Table row 를 업데이트 하는 상황을 방어하기 위해 어떻게 개발하실 건지 설명해주세요.

비즈니스 요구사항에 따라 해결 방법이 달라질 것 같습니다.

일반적으로 DB Table row를 동시에 읽고 덮어쓰지 못하도록 RDBMS의 트랜잭션 기능과 락을 이용하여 여러 트랜잭션이 한 row를 동시에 덮어쓰지 못하도록 할 수 있습니다.
row에 락을 거는 방식에는 비관적 락과 낙관적 락인 방식이 존재합니다.

## 비관적 락
비관적 락은 DB단에서 제공하는 물리적인 락 기능을 이용하여 잠금을 거는 방식을 말합니다.
MySQL InnoDB 기준으로 `select ~ for update`, `select ~ lock in share mode`구문으로 명시적으로 x, s락을 획득하며 조회할 수 있습니다.
`update`문이 실행될 때도 해당 row에 대해서 x락을 획득하게 됩니다.
s락은 한 row에 대해서 여러 트랜잭션이 동시에 획득할 수 있고 s락이 걸려있는 row는 x락을 획득할 수 없습니다.
x락은 한 row에 대해서 한 트랜잭션만 획득이 가능하고 s락과도 같이 걸릴 수 없습니다.
A 트랜잭션이 row에 접근하여 수정중일 때 B 트랜잭션이 row에 접근하지 못하게 하려면, 트랜잭션 안에서 row를 읽어오는 구문에 x락을 걸면서 읽어오면 동시에 읽지 못하게 할 수 있습니다.

이런 비관적 락 방식을 사용하면 한번에 한 row에 대해서는 한 트랜잭션만 접근하게 구현할 수 있습니다.

## 낙관적 락
물리적인 락을 걸지 않고 row에 대한 동시 수정을 방지하는 방법입니다.
table의 column에 version 값을 추가하고 트랜잭션에서 덮어쓸 때마다 읽어온 version을 1씩 올려가면서 덮어씁니다.
만약 다른 트랜잭션이 row에 동시에 접근해서 해당 version 값을 먼저 올려놔서 같은 값으로 덮어쓰게 된다면, 충돌이 일어났다고 간주하고 트랜잭션을 실패처리하거나, 처음부터 재시도합니다.

## 비관적 락과 낙관적 락의 비교
낙관적 락은 이름 그대로 충돌이 일어나는 상황이 자주 발생하지 않을 것이라고 낙관적으로 여기고 사용되는 방법입니다.
일반적인 충돌상황의 경우 물리적인 락을 사용하는 비관적 락 방식보다 낙관적 락 방식이 성능이 더 좋습니다.
하지만, 많은 트랜잭션이 한 row에 접근하여 덮어쓰는 상황에서는 한 트랜잭션씩 차근차근 성공하는 비관적 락이 더 성능이 좋습니다.
낙관적 락의 경우 너무 많은 트랜잭션이 한 row에 접근한다면, 많은 트랜잭션이 실패하고 재시도하는 과정에서 물리 락을 사용하는 비용보다 더한 컴퓨팅 리소스를 사용할 수 있습니다.

따라서, 동시성은 보장해야 하지만 많은 트래픽이 몰리지 않을 경우는 낙관적 락을 이용할 수 있을 것 같고, 
많은 트래픽이 몰려 여러 트랜잭션에 대해 하나씩 차근차근 수행해야 하는 경우엔 비관적 락을 이용하는게 좋다고 생각합니다.

## 오프라인 선점 잠금
row에 대한 동시성을 보장하더라도 사용자 입장에선 자신이 변경한 내용이 같은 시점에 다른 사용자와 같이 접근했을 때 비즈니스적으로 문제가 발생할 수 있습니다.

ex) 영화 예매
A사용자 -> 예매화면 출력(빈좌석 1,2,3,4) --> 1,2좌석 예매선택 --> 1,2좌석 결제 페이지로 이동 --> 1,2좌석 결제 --> 1,2좌석에 A사용자가 예매했다는 데이터가 DB에 반영
B사용자 ---> 예매화면 출력(빈좌석 1,2,3,4) ----------> 1,2좌석 예매선택 --> 1,2좌석 결제 페이지로 이동 --> 1,2좌석 결제 --> A사용자가 먼저 예매하여 트랜잭션 실패
C사용자 ------------------------------> 예매화면 출력(빈좌석 1,2,3,4) --> 3,4좌석 예매선택 --> 3,4좌석 결제 페이지로 이동 --> 3,4좌석 결제 --> 3,4좌석에 C사용자가 예매했다는 데이터가 DB에 반영

위 상황에선 B사용자의 경우 결제 정보를 입력하는 화면에서 이미 다른 사용자가 해당 좌석을 예매해버려서 최종적으로 예매를 실패하고, 남은 좌석도 다른 사용자가 결제중이라, 결제할 수 없는 상황이 됩니다. DB Table row에 락을 잘 적용하여 시스템상의 동시성 이슈를 해결했더라도 사용자 경험 측면에선 이슈가 해결되지 않았을 수 있습니다.

이러한 경우에 `오프라인 선점 잠금`이라는 기법을 사용할 수 있습니다.
위 경우에서 예를 들면 1,2좌석 결제 페이지에 접근하는 사용자를 한 명으로 제한하도록 비즈니스적인 락을 거는 방법입니다.
예매 페이지에 접근하는 락 정보를 담은 테이블을 따로 구성하여, 동시에 여러 사용자가 한 예매 페이지에 접근하는 것 자체를 막는 로직을 구현하면 B사용자가 결제 정보를 모두 입력하기 전에 1,2좌석 예매를 하지 않게 할 수 있습니다.
